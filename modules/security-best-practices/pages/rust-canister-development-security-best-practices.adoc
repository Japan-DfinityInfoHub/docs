= Rust Canister 開発セキュリティ・ベストプラクティス

== スマートコントラクトの Canister コントロール

=== SNS のような分散型ガバナンスシステムを使い、Canister に分散型コントローラーを持たせます

==== セキュリティ上の懸念事項

Canister のコントローラーは、好きなときに Canister を変更・更新することができます。Canister が ICP などのアセットを保存している場合、コントローラーが Canister を更新することでアセットを盗み、Cycle を自分のアカウントに転送できることを意味します。

==== 推奨

* Canister のコントロールを Internet Computer の Service Nervous System（SNS）のような分散型ガバナンスシステムに渡すことを検討し、SNS コミュニティが投票によって集団的に承認した場合のみ、 Canister への変更が実行されるようにします。SNS を使用する場合、SNS のサブネット上の SNS を使用することで、NNS のバージョンを継承した SNS を実行しており、IC の一部として維持されていることが保証されます。これらの SNS は近日中に公開される予定です。link:https://dfinity.org/roadmap/[ロードマップ] と link:https://forum.dfinity.org/t/open-governance-canister-for-sns-design-proposal/10224[設計提案] を参照してください。
* もう一つの選択肢は、Canister コントローラーを完全に削除して、イミュータブル Canister スマートコントラクトを作成することです。しかし、これは Canister のアップグレードができないことを意味し、例えばバグが見つかった場合に、深刻な影響を与える可能性があることに注意してください。分散型ガバナンスシステムを使用し、スマートコントラクトをアップグレードできるオプションは、他のブロックチェーンと比較して、Internet Computer のエコシステムの大きな利点です。
** 他のブロックチェーンとは異なり、（IC の）イミュータブル・スマートコントラクトは実行に Cycle を必要とし、また Cycle を受け取ることができることに留意してください。
* IC 上に DAO（link:https://en.wikipedia.org/wiki/Decentralized_autonomous_organization[分散型自律組織] ）をゼロから実装することも可能です。これを行う場合（例えばlink:https://smartcontracts.org/docs/samples/dao.html[基本的なDAOの例] のような形で）、セキュリティ的に危険性があり、慎重にセキュリティレビューする必要があることに注意してください。さらに、ユーザーは DAO が DAO 自身によって制御されていることを確認する必要があります。

=== 依存するスマートコントラクトの所有権を検証します

==== セキュリティ上の懸念事項

Canister が他の Canister のスマートコントラクトに依存する（つまり、Canister 間コールを行う）場合、依存する Canister のスマートコントラクトが分散型ガバナンスシステムによって所有されていることが不可欠です。そうでなければ、つまりコントローラーがいれば、他の人に気づかれることなくスマートコントラクトを変更し、例えば Canister が保有するアセットを盗むことができます。

==== 推奨

分散型であることを求める Canister とやり取りする場合は、NNS、Service Nervous System（SNS）、分散型ガバナンスシステムによってコントロールされていることを確認し、どのような条件で、誰によってスマートコントラクトが変更できるかを確認しましょう。

== 認証

=== 特定のユーザーにとって認証が必要であるアクションを確認します

==== セキュリティ上の懸念事項

以下が当てはまらない場合、攻撃者はユーザーの代わりに機密性の高い操作を行うことができ、ユーザーのアカウントを危険にさらす可能性があります。

==== 推奨

- デザイン上、すべての Canister のコールに対して、コール元を特定することができます。コール元の link:https://smartcontracts.org/docs/interface-spec/index.html#principal[Principal] には、システム API のメソッド `ic0.msg_caller_size` と `ic0.msg_caller_copy` （link:https://docs.dfinity.systems/spec/public/#system-api-imports[ここ] を参照）を使ってアクセスすることができます。Internet Identity などを使用する場合、Principal はこの特定のオリジン、ユーザー Identity になります。link:https://github.com/dfinity/internet-identity/blob/main/docs/internet-identity-spec.adoc#identity-design-and-data-model[ここ] を参照してください。一部のアクション（ユーザーのアカウントデータへのアクセスやアカウント固有の操作など）を Principal または Principal のセットに制限する必要がある場合、Rust で以下のように、Canister のコールで明示的に確認する必要があります。

```rust
    // この操作の実行を許可された Principal の公開鍵を pk とします。
    // この pk は Canister のステートに格納される可能性があります。 
    if caller() != Principal::self_authenticating(pk) {  ic_cdk::trap(...) }

    // あるいは、Canister が異なる Principal のデータを BTreeMap<Principal, UserData> 
    // のようなマップに保持する場合、Canister は各呼び出し元が自分のデータにのみアクセスし操作を
    // 実行できるようにする必要があります：
    if let Some(user_data) = user_data_store.get_mut(&caller()) {
    	// ユーザーのデータに対して操作を行う
    }
```


- Rust では、`ic_cdk` クレートを使用して、`ic_cdk::api::caller` による呼び出し元の認証が可能です。返される Principal が `Principal::self_authenticating` 型であることを確認し、その Principal の公開鍵を用いてユーザのアカウントを特定します （上記のサンプルコードを参照してください）。
- 認証されないアクションや認証前の潜在的に高価であろう操作を避けるために、できるだけ呼び出しの早い段階で認証を行います。link:rust-canister-development-security-best-practices#disallow-the-anonymous-principal[deny service to anonymous users] を参照するのもよいアイデアです。

[[disallow-the-anonymous-principal]]
=== 認証されたコールで匿名 Principal を許可しない

==== セキュリティ上の懸念事項

`ic0::api::caller` は `Principal::anonymous()` も返すかもしれません。認証されたコールにおいて、これはおそらく望ましくないでしょう（そしてセキュリティに影響を与える可能性があります）。なぜなら、認証されていないコールをする人にとって、これは共有アカウントのように振る舞うからです。

==== 推奨

認証された呼び出しでは、コール元が匿名でないことを確認し、匿名である場合はエラーまたはトラップを返します。これは、例えば以下のようなヘルパーメソッドを使用することで一元的に行うことができます：

```rust
fn caller() -> Result<Principal, String> {
    let caller = ic0::api::caller();
    // 匿名 Principal は Canister と対話することを許可されていません。
    if caller == Principal::anonymous() {
        Err(String::from(
            "Anonymous principal not allowed to make calls.",
        ))
    } else {
        Ok(caller)
    }
}
```

== アセット認証

=== HTTP アセット認証を使用し、`raw.ic0.app` を通して Dapp を提供しないようにします

==== セキュリティ上の懸念事項

IC 上の Dapps は、link:https://wiki.internetcomputer.org/wiki/HTTP_asset_certification[asset certification] を使って、ブラウザに配信される HTTP アセットが本物である（つまり、サブネットによって閾値署名されている）ことを確認することができます。アプリがアセット認証を行わない場合、アセット認証がチェックされない `raw.ic0.app`  を通してのみ安全に提供することができます。これは、単一の悪意のあるノードまたはバウンダリノードが、ブラウザに配信されるアセットを自由に変更できるため、安全ではありません。

アプリが `ic0.app` に加えて `raw.ic0.app` を通して提供される場合、攻撃者は安全でない raw.ic0.app を使用させて（フィッシングのような）ユーザーを騙す攻撃の可能性があります。

==== 推奨

- サービスワーカーがアセット認証を確認する `<canister-id>.ic0.app` を通してのみ、アセットを提供します。`<canister-id>.raw.ic0.app` を通してアセットを提供しないでください。
- アセット Canister を使用してアセットを配信するか（アセット証明書を自動的に作成する）、または例えば、 link:https://github.com/dfinity/nns-dapp[NNS Dapp] や link:https://github.com/dfinity/internet-identity[Internet Identity] で行われているように、アセット証明書を含む `ic-certificate` ヘッダを追加してください。
- Canister の `http_request` メソッドで、リクエストが raw で送られてきたかどうかを確認します。もしそうなら、エラーを返して、アセットを提供しないようにします。

== Canister ストレージ

=== ステート変数のために `Cell/RefCell` で `thread_local!` を使用し、すべてのグローバルを1つのバスケットに入れます

==== セキュリティ上の懸念事項

Canister には、グローバルなミュータブルステートが必要です。Rust では、これを実現するためにいくつかの方法があります。しかし、いくつかのオプションでは、例えばメモリ破壊を引き起こすような危険性を伴います。

==== 推奨

- link:https://mmapped.blog/posts/01-effective-rust-canisters.html#use-threadlocal[Use `thread_local!` with `Cell/RefCell` for state variables.]  （link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters] から）
- link:https://mmapped.blog/posts/01-effective-rust-canisters.html#clear-state[Put all your globals in one basket.] （link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters] から）

=== ユーザーごとに Canister に保存できるデータ量の制限します

==== セキュリティ上の懸念事項

ユーザーが大量のデータを Canister に保存する場合、これを悪用し Canister のストレージを満杯にし使用できなくする可能性があります。

==== 推奨

ユーザー毎に Canister に保存できるデータ量を制限します。アップデートコールでユーザーのデータが保存されるたびに、この制限を確認する必要があります。

=== ステーブルメモリの使用を考慮し、バージョンアップし、テストします

==== セキュリティ上の懸念事項

Canister メモリは、アップグレードをまたいで保持されることはありません。アップグレードをまたいでデータを保持する必要がある場合、`pre_upgrade` で　Canister メモリをシリアライズし、`post_upgrade` でそれをデシリアライズするのが自然な方法でしょう。しかし、これらの方法で利用できる命令数には限りがあります。メモリが大きくなりすぎると、Canister を更新することができなくなります。

==== 推奨

- ステーブルメモリは、アップグレードしても持続するので、この問題に対処するために使用することができます。
- link:https://mmapped.blog/posts/01-effective-rust-canisters.html#stable-memory-main[Consider using stable memory.] （link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters] から） そこで語られているデメリットも参照してください。
- link:https://mmapped.blog/posts/01-effective-rust-canisters.html#version-stable-memory[Version stable memory.] （link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters] から）
- link:https://mmapped.blog/posts/01-effective-rust-canisters.html#test-upgrades[Test the upgrade hooks.] （link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters] から）
- link:https://www.joachim-breitner.de/blog/788-How_to_audit_an_Internet_Computer_canister[How to audit an Internet Computer canister（Internet Computer Canister の監査方法）] の upgrade のセクションも参照してください（ただし、Mokoto が対象）。
- バグを回避するためにステーブルメモリのためのテストを書きましょう。
- 開発者が作業しているいくつかのライブラリ（ほとんどが作業中か一部未完成）：
** link:https://github.com/dfinity/stable-structures/[https://github.com/dfinity/stable-structures/]
*** HashMap: link:https://github.com/dfinity/stable-structures/pull/1[https://github.com/dfinity/stable-structures/pull/1] （現在、prod ready ではありません）
** link:https://github.com/seniorjoinu/ic-stable-memory-allocator[https://github.com/seniorjoinu/ic-stable-memory-allocator]
- link:https://wiki.internetcomputer.org/wiki/Current_limitations_of_the_Internet_Computer[Current limitations of the Internet Computer（インターネット・コンピュータの現在の制限）] のセクション "Long running upgrades" と "[de]serialiser requiring additional wasm memory" を御覧ください。
- 例えば、link:https://github.com/dfinity/internet-identity[internet identity] は、ユーザーデータを保存するためにステーブルメモリを直接使用します。

=== Canister の機密データ暗号化を検討します

==== セキュリティ上の懸念事項

デフォルトでは、Canister は整合性を提供しますが、機密性は提供しません。Canister に保存されたデータはノード／レプリカが読み取ることができます。

==== 推奨

- Canister 上のあらゆる個人情報（ユーザーの個人情報やプライベートな情報など）をエンドツーエンドで暗号化することを検討しましょう。
- 例として Dapp link:https://github.com/dfinity/examples/tree/master/motoko/encrypted-notes-dapp[Encrypted Notes（暗号化ノート）] ではエンドツーエンドの暗号化が可能であることを説明しています。

=== バックアップを作成します

==== セキュリティ上の懸念事項

以下の理由により、Canister が使用不能になり二度とアップグレードできなくなる可能性があります：

* アップグレードプロセスに不具合がある（アプリ開発者のバグによる）。
* データを永続化するコードのバグにより、状態が不整合、若しくは破損する。

==== 推奨
- アップグレードに使用される方法がテストされていることを確認、または Canister をイミュータブルにしましょう。
- Canister を再インストールできるように、ディザスタリカバリ戦略を立てておくと便利です。
- link:https://www.joachim-breitner.de/blog/788-How_to_audit_an_Internet_Computer_canister[How to audit an Internet Computer canister（Internet Computer Canister の監査方法）] の "Backup and recovery" のセクションを参照してください。

== Canister 間コールとロールバック

=== await の後にパニックを起こさない、await のバウンダリを越えて共有リソースをロックしない

==== セキュリティ上の懸念事項

パニックやトラップは、Canister のステートをロールバックします。そのため、トラップやパニックが発生した後のステートの変化には注意が必要です。これは Canister 間のコールが行われる場合にも重要な懸念事項となります。Canister 間コールの `await` の後にパニックやトラップが発生すると、Canister 間コールのコールバック呼び出しの前のスナップショットにステートが戻されます （コール全体の前ではありません！）。

これは例えば、次のような問題を引き起こす可能性があります：

- Canister 間コール前のステート変更でステートが一貫せず、Canister 間コール後にパニックが発生すると、Canister のステートが一貫しないことになります。
- 特に、Canister 間コール前に割り当てられたリソース （ロックやメモリなど） が解放されないと、Canister が永遠にロックされるなどの問題が発生する可能性があります。
- 一般に、開発者が期待したときにデータが永続化されないとバグが発生することがあります。

==== 推奨

- link:https://mmapped.blog/posts/01-effective-rust-canisters.html#panic-await[Don’t panic after `await`] （link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters] から）
- link:https://mmapped.blog/posts/01-effective-rust-canisters.html#dont-lock[Don't lock shared resources across await boundaries] （link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters] から）
- link:https://www.joachim-breitner.de/blog/788-How_to_audit_an_Internet_Computer_canister[How to audit an Internet Computer canister（Internet Computer Canister の監査方法）] の ”Inter-canister calls" のセクションを参照してください。
- コンテキストについては、link:https://docs.dfinity.systems/spec/public/#rule-message-execution[IC interface spec on message execution] を参照してください。

=== Canister 間コール中にステートが変化する可能性があるため注意します

==== セキュリティ上の懸念事項

メッセージは（コール全体ではなく）アトミックに処理されます。これは、以下のようなセキュリティ問題を引き起こす可能性があります：

- Time-of-check time-of-use：Canister 間コールの前にグローバルなステートに関するある条件をチェックし、コールが戻ったときにそれがまだ保持されていると誤って仮定してしまうこと。

==== 推奨

- Canister 間のコール中にステートが変化する可能性があることに注意してください。このようなバグが発生しないように、慎重にコードを見直してください。
- link:https://www.joachim-breitner.de/blog/788-How_to_audit_an_Internet_Computer_canister[How to audit an Internet Computer canister（Internet Computer Canister の監査方法）] の "Inter-canister calls” セクションを参照してください。

=== 信頼できる Canister に対してのみ、Canister 間コールを行います

==== セキュリティ上の懸念事項

- 悪意のある可能性のある Canister に Canister 間コールが行われた場合、DoS 問題につながる可能性があり、また、Candid のデコードに関連する問題がある可能性があります。また、Canister コールから返されたデータが信頼できないにもかかわらず、信頼できると見なされる可能性があります。
- Canister がコールバックで呼び出された場合、Peer がレスポンスしないとレシーバーが無制限にストールし DoS が発生する可能性があります。Canister がそのようなステートになると、もはやアップグレードすることはできません。回復には、再インストール、Canister のステート消去が必要です。
- 要約すると、Canister の動作が Canister 間コールレスポンスに依存する場合、Canister の DoS、過剰なリソースの消費、またはロジックバグの原因となる可能性があるということです。

==== 推奨

- 信頼できる Canister への Canister 間コールのみを行いましょう。
- Canister 間コールから返されたデータを消去しましょう。
- link:https://www.joachim-breitner.de/blog/788-How_to_audit_an_Internet_Computer_canister[How to audit an Internet Computer canister（Internet Computer Canister の監査方法）] の "Talking to malicious canisters” セクションを参照してください。
- link:https://wiki.internetcomputer.org/wiki/Current_limitations_of_the_Internet_Computer[Current limitations of the Internet Computer（インターネット・コンピュータの現在の制限）] のセクション "Calling potentially malicious or buggy canisters can prevent canisters from upgrading" を参照してください。

=== コールグラフにループがないことを確認します

==== セキュリティ上の懸念事項

コールグラフのループ（例：Canister A が B を呼び出し、B が C を呼び出し、C が A を呼び出す）により、Canister のデッドロックが発生する場合があります。

==== 推奨

- このようなループは避けましょう!
- 詳しくは、link:https://wiki.internetcomputer.org/wiki/Current_limitations_of_the_Internet_Computer[Current limitations of the Internet Computer（インターネットコンピュータの現在の制限）] セクション "Loops in call graphs" を参照してください。

== Canister アップグレード

=== アップグレード中のパニックに注意します

==== セキュリティ上の懸念事項

もし Canister が `pre_upgrade` でトラップやパニックを起こすと、Canister を恒久的にブロックすることになり、結果としてアップグレードが失敗したり、まったくできなくなったりすることがあります。

==== 推奨

- 本当に回復不可能な場合を除き、`pre_upgrade` フックでのパニックやトラップは避け、無効な状態をアップグレードで修正できるようにしましょう。pre-upgrade フックでのパニックはアップグレードを妨げますし、pre-upgrade フックは古いコードによって制御されているので、アップグレードを永久にブロックすることができます。
- `post_upgrade` フックでは、ステートが無効な場合にパニックを発生させ、アップグレードを再試行して無効な状態の修正を試みることができるようにします。post_upgrade フックでのパニックはアップグレードを中断させますが、新しいコードで再試行することができます。
- link:https://mmapped.blog/posts/01-effective-rust-canisters.html#test-upgrades[Test the upgrade hooks.] （link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters] から）
- link:https://www.joachim-breitner.de/blog/788-How_to_audit_an_Internet_Computer_canister[How to audit an Internet Computer canister（Internet Computer Canister の監査方法）] の upgrade のセクションも参照してください（ただし、Mokoto が対象）。
- link:https://wiki.internetcomputer.org/wiki/Current_limitations_of_the_Internet_Computer[Current limitations of the Internet Computer（インターネットコンピュータの現在の制限）] のセクション "Bugs in `pre_upgrade` hooks" を参照してください。

== その他

[[test-your-canister-code]]
=== システム API コールが存在する場合でも、Canister コードをテストします

==== セキュリティ上の懸念事項

Canister はシステム API と相互作用するため、ユニットテストではシステム API を呼び出すことができないためコードのテストが難しくなります。このため、ユニットテストが不足する可能性があります。

==== 推奨

- システム API に依存しない疎結合のモジュールを作成し、それらをユニットテストする。この link:https://mmapped.blog/posts/01-effective-rust-canisters.html#target-independent[recommendation] （link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters] から）を参照してください。
- システム API とまだ相互作用する部分については、システム API の薄い抽象化を作成し、ユニットテストでフェイクを行います。link:https://mmapped.blog/posts/01-effective-rust-canisters.html#target-independent[recommendation] （link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters] から）を参照してください。例えば、以下のように ”Runtime” を実装し、テストでは ”MockRuntime” を使用することができます（コード：Dimitris Sarlis）。

```rust
    use ic_cdk::api::{
        call::call, caller, data_certificate, id, print, time, trap,
    };

    #[async_trait]
    pub trait Runtime {
        fn caller(&self) -> Result<Principal, String>;
        fn id(&self) -> Principal;
        fn time(&self) -> u64;
        fn trap(&self, message: &str) -> !;
        fn print(&self, message: &str);
        fn data_certificate(&self) -> Option<Vec<u8>>;
        (...)
    }

    #[async_trait]
    impl Runtime for RuntimeImpl {
        fn caller(&self) -> Result<Principal, String> {
            let caller = caller();
            // 匿名 Principal は Canister と対話することはできません
            if caller == Principal::anonymous() {
                Err(String::from(
                    "Anonymous principal not allowed to make calls.",
                ))
            } else {
                Ok(caller)
            }
        }

        fn id(&self) -> Principal {
            id()
        }

        fn time(&self) -> u64 {
            time()
        }

        (...)

    }

    pub struct MockRuntime {
        pub caller: Principal,
        pub canister_id: Principal,
        pub time: u64,
        (...)
    }

    #[async_trait]
    impl Runtime for MockRuntime {
        fn caller(&self) -> Result<Principal, String> {
            Ok(self.caller)
        }

        fn id(&self) -> Principal {
            self.canister_id
        }

        fn time(&self) -> u64 {
            self.time
        }

        (...)

    }
```


=== Canister ビルドの再現性を高めます

==== セキュリティ上の懸念事項

Canister が主張することを実行するかどうかを検証することができるはずです。IC はデプロイされた WASM モジュールの SHA 256 ハッシュを提供します。これが有用であるためには Canister のビルドが再現可能である必要があります。

==== 推奨

Canister のビルドを再現できるようにする。この link:https://mmapped.blog/posts/01-effective-rust-canisters.html#reproducible-builds[recommendation] を見てください（link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters] から）。link:https://smartcontracts.org/docs/developers-guide/tutorials/reproducible-builds.html[Developer docs on this] も参照してください。

=== Canister からメトリクスを公開します

==== セキュリティ上の懸念事項

攻撃された場合、アカウント数、内部データ構造のサイズ、ステーブルメモリなど、Canister から関連するメトリクスを取得できるのは素晴らしいことです。

==== 推奨

link:https://mmapped.blog/posts/01-effective-rust-canisters.html#expose-metrics[Expose metrics from your canister.] （link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters] から）

=== 時間が厳密に単調であるわけでなく依存してはいけません

==== セキュリティ上の懸念事項

System API から読み込まれる時刻は単調ですが、厳密には単調ではありません。そのため後続の2回の呼び出しで同じ時刻を返すことがあり、time API を使用した場合にセキュリティバグが発生する可能性があります。

==== 推奨

link:https://www.joachim-breitner.de/blog/788-How_to_audit_an_Internet_Computer_canister[How to audit an Internet Computer canister（Internet Computer Canister の監査方法）] の セクション "Time is not strictly monotonic” を参照してください。

[[protect-against-draining-the-cycles-balance]]
=== Cycle バランスのドレインを防ぎます

==== セキュリティ上の懸念事項

Canister は Cycle を消費するため、Cycle を消費する攻撃には本質的に脆弱です。

==== 推奨

これを軽減するために、Canister レベルでの監視、早期認証、レート制限を検討してください。また、攻撃者は最も多くの Cycle を消費しているコールを狙っていることに注意してください。link:https://www.joachim-breitner.de/blog/788-How_to_audit_an_Internet_Computer_canister[How to audit an Internet Computer canister（Internet Computer Canister の監査方法）] の "Cycle balance drain attacks section” を参照してください。

== Internet Computer に特有でなく一般的なベストプラクティス

このセクションのベストプラクティスは非常に一般的なものであり、Internet Computer に特化したものではありません。このリストは決して完全なものではなく、過去に問題になった非常に具体的な懸念事項をいくつか挙げているに過ぎません。

=== インプットの検証

==== セキュリティ上の懸念事項

link:https://smartcontracts.org/docs/interface-spec/index.html#http-interface[query and update calls] で送信されるデータは一般的に信頼できません。メッセージサイズの上限は数 MB です。これは、例えば以下のような問題を引き起こす可能性があります。

- 検証されていないデータが Web UI でレンダリングされたり、他のシステムで表示された場合、インジェクション攻撃（XSS など）につながる可能性があります。
- 大きなサイズのメッセージが送信され、Canister に保存される可能性があり、ストレージを過剰に消費します。
- 大きなインプット（大きなリストや文字列など）は過剰な計算を引き起こし、DoS の原因となり、多くの Cycle を消費する可能性があります。link:rust-canister-development-security-best-practices#protect-against-draining-the-cycles-balance[Protect against draining the cycles balance] も参照してください。

==== 推奨

- 入力検証を行いましょう。例えば、link:https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html[OWASP cheat sheet] を参照してください。
- link:https://www.joachim-breitner.de/blog/788-How_to_audit_an_Internet_Computer_canister[How to audit an Internet Computer canister（Internet Computer Canister の監査方法）] のセクション "Large data attacks" （Candid space bombs に注意してください）を御覧ください。
- link:https://owasp.org/www-project-application-security-verification-standard/[ASVS] の 5.1.4：型設定が強化・構造化されたデータ、許容される文字、長さ、パターンを含む定義されたスキーマに照らして検証されること （例：クレジットカード番号、電話、または郵便番号が一致するかどうかなど、関連する二つのフィールドが妥当かどうか検証すること）。

=== Rust：安全でない Rust コードを使ってはいけません

==== セキュリティ上の懸念事項

安全でない Rust コードはメモリ破壊の問題を引き起こす可能性があるため危険です

==== 推奨

- 安全でないコードは可能な限り避けてください。
- link:https://anssi-fr.github.io/rust-guide/04_language.html#unsafe-code[Rust security guidelines] を参照してください。
- link:https://docs.dfinity.systems/dfinity/spec/meta/rust.html#_avoid_unsafe_code[Dfinity Rust Guidelines] を検討してください。

=== Rust： integerのオーバーフローを回避します

==== セキュリティ上の懸念事項

Rust の integer はオーバーフローすることがあります。このようなオーバーフローはデバッグ環境ではパニックになりますが、リリースコンパイルでは値はただ黙ってラップされるだけです。これは、例えば integer をインデックスやユニーク ID として使用する場合や、Cycle や ICP 数量を計算する場合などに、セキュリティ上の大きな問題を引き起こす可能性があります。

==== 推奨

- ラップする可能性のある整数演算がないか、コードを注意深く見直してください。
- これらの演算には、 `saturated_add` や `saturated_sub` 、 `checked_add` 、 `checked_sub` などの `saturated` や `checked` のバリアントを使用する。例えば、 `u32` については link:https://doc.rust-lang.org/std/primitive.u32.html#method.saturating_add[Rust docs] を参照してください。
- link:https://anssi-fr.github.io/rust-guide/04_language.html#integer-overflows[Rust security guidelines on integer overflows] も参照してください。

=== 高額なコール料については、Captcha や proof of work の利用を検討します

==== セキュリティ上の懸念事項

アップデートやクエリのコールが使用するメモリや消費する Cycle などの点で高価な場合、ボットが Canister を使用不能にすることが容易になります（例えば、ストレージを一杯にすることなどによって）。

==== 推奨

Dapp がそのような操作を提供する場合、Captcha や proof of work を追加するなどのボット対策テクニックを検討します。例えば、link:https://github.com/dfinity/internet-identity[internet identity] に Captcha の実装があります。



////
= Rust Canister Development Security Best Practices

== Smart Contracts Canister Control

=== Use a decentralized governance system like SNS to make a canister have a decentralized controller

==== Security Concern

The controller of a canister can change / update the canister whenever they like. If a canister e.g. stores assets such as ICP, this effectively means that the controller can steal these by updating the canister and transfer the cycles to their account.

==== Recommendation

* Consider passing canister control to a decentralized governance system such as the Internet Computer's Service Nervous System (SNS), so that changes to the canister are only executed if the SNS community approves them collectively through voting. If an SNS is used, use an SNS on the SNS subnet as this guarantees that the SNS is running an NNS-blessed version and maintained as part of the IC. These SNSs will be available soon. See the link:https://dfinity.org/roadmap/[roadmap] and the link:https://forum.dfinity.org/t/open-governance-canister-for-sns-design-proposal/10224[design proposal]
* Another option would be to create an immutable canister smart contract by removing the canister controller completely. However, note that this implies that the canister cannot be upgraded, which may have severe implications in case e.g. a bug were found. The option to use a decentralized governance system and thus being able to upgrade smart contracts is a big advantage of the Internet Computer ecosystem compared to other blockchains.
**  Note that, contrary to some other blockchains, also immutable smart contracts need cycles to run, and they can receive cycles.
* It is also possible to implement a DAO (link:https://en.wikipedia.org/wiki/Decentralized_autonomous_organization[Decentralized Autonomous Organization]) on the IC from scratch. If you decide to do this (e.g. along the lines of the link:https://smartcontracts.org/docs/samples/dao.html[basic DAO example]), be aware that this is security critical and must be security reviewed carefully. Furthermore, users will need to verify that the DAO is controlled by itself.

=== Verify the ownership of smart contracts you depend on

==== Security Concern

If a canister depends on another canister smart contract (i.e. makes inter-canister calls to it), it is essential that the canister smart contract that one depends on is owned by a decentralized governance system. Otherwise, i.e. if it has a controller, they could modify the smart contract without others noticing, e.g. to steal assets held by the canister.

==== Recommendation

If you interact with a canister that you require to be decentralized, make sure it is controlled by the NNS, a service nervous system (SNS) or a decentralized governance system, and review under what conditions and by whom the smart contract can be changed.

== Authentication

=== Make sure any action that only a specific user should be able to do requires  authentication

==== Security Concern

If this is not the case, an attacker may be able to perform sensitive actions on behalf of a user, compromising their account.

==== Recommendation

- By design, for every canister call the caller can be identified. The calling link:https://smartcontracts.org/docs/interface-spec/index.html#principal[principal] can be accessed using the system API’s methods `ic0.msg_caller_size` and `ic0.msg_caller_copy` (see link:https://docs.dfinity.systems/spec/public/#system-api-imports[here]). If e.g. Internet Identity is used, the principal is the user identity for this specific origin, see link:https://github.com/dfinity/internet-identity/blob/main/docs/internet-identity-spec.adoc#identity-design-and-data-model[here]. If some actions (e.g. access to user’s account data or account specific operations) should be restricted to a principal or a set of principals, then this must be explicitly checked in the canister call, for example as follows in Rust:

```rust
    // Let pk be the public key of a principal that is allowed to perform 
    // this operation. This pk could be stored in the canister's state. 
    if caller() != Principal::self_authenticating(pk) {  ic_cdk::trap(...) }

    // Alternatively, if the canister keeps data for different principals 
    // in e.g. a map such as BTreeMap<Principal, UserData>, then the canister 
    // must ensure that each caller can only access and perform operations 
    // on their own data:
    if let Some(user_data) = user_data_store.get_mut(&caller()) {
    	// perform operations on the user's data
    }
```


- In Rust, the `ic_cdk` crate can be used to authenticate the caller using `ic_cdk::api::caller`. Make sure the returned principal is of type `Principal::self_authenticating`  and identify the user’s account using the public key of that principal, see the example code above.
- Do authentication as early as possible in the call to avoid unauthenticated actions and potentially expensive operations before authentication. It is also a good idea to link:rust-canister-development-security-best-practices#disallow-the-anonymous-principal[deny service to anonymous users].

[[disallow-the-anonymous-principal]]
=== Disallow the anonymous principal in authenticated calls

==== Security Concern

`ic0::api::caller` may also return `Principal::anonymous()`. In authenticated calls, this is probably undesired (and could have security implications) since this would behave like a shared account for anyone that does unauthenticated calls.

==== Recommendation

In authenticated calls, make sure the caller is not anonymous and return an error or trap if it is. This could e.g. be done centrally by using a helper method such as:

```rust
fn caller() -> Result<Principal, String> {
    let caller = ic0::api::caller();
    // The anonymous principal is not allowed to interact with canister.
    if caller == Principal::anonymous() {
        Err(String::from(
            "Anonymous principal not allowed to make calls.",
        ))
    } else {
        Ok(caller)
    }
}
```

== Asset Certification

=== Use HTTP asset certification and avoid serving your dApp through `raw.ic0.app`

==== Security Concern

dApps on the IC can use link:https://wiki.internetcomputer.org/wiki/HTTP_asset_certification[asset certification] to make sure the HTTP assets delivered to the browser are authentic (i.e. threshold-signed by the subnet). If an app does not do asset certification, it can only be served insecurely through `raw.ic0.app` , where no asset certification is checked. This is insecure since a single malicious node or boundary node can freely modify the assets delivered to the browser.

If an app is served through `raw.ic0.app` in addition to `ic0.app`, an adversary may trick users (phishing) into using the insecure raw.ic0.app.

==== Recommendation

- Only serve assets through `<canister-id>.ic0.app` where the service worker verifies asset certification. Do not serve through `<canister-id>.raw.ic0.app`.
- Serve assets using the asset canister (which creates asset certification automatically), or add the `ic-certificate` header including the asset certification as e.g. done in the link:https://github.com/dfinity/nns-dapp[NNS dApp] or link:https://github.com/dfinity/internet-identity[Internet Identity].
- Check in the canister’s `http_request` method if the request came through raw. If so, return an error and do not serve any assets.

== Canister Storage

=== Use `thread_local!` with `Cell/RefCell` for state variables and put all your globals in one basket.

==== Security Concern

Canisters need global mutable state. In Rust, there are several ways to achieve this. However, some options can lead e.g. to memory corruption.

==== Recommendation

- link:https://mmapped.blog/posts/01-effective-rust-canisters.html#use-threadlocal[Use `thread_local!` with `Cell/RefCell` for state variables.] (from link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters])
- link:https://mmapped.blog/posts/01-effective-rust-canisters.html#clear-state[Put all your globals in one basket.] (from link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters])

=== Limit the amount of data that can be stored in a canister per user

==== Security Concern

If a user is able to store a big amount of data on a canister, this may be abused to fill up the canister storage and make the canister unusable.

==== Recommendation

Limit the amount of data that can be stored in a canister per user. This limit has to be checked whenever data is stored for a user in an update call.

=== Consider using stable memory, version it, test it

==== Security Concern

Canister memory is not persisted across upgrades. If data needs to be kept across upgrades, a natural thing to do is to serialize the canister memory in `pre_upgrade`, and deserialize it in `post_upgrade`. However, the available number of instructions for these methods is limited. If the memory grows too big, the canister can no longer be updated.

==== Recommendation

- Stable memory is persisted across upgrades and can be used to address this issue.
- link:https://mmapped.blog/posts/01-effective-rust-canisters.html#stable-memory-main[Consider using stable memory.] (from link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters]). See also the disadvantages discussed there.
- link:https://mmapped.blog/posts/01-effective-rust-canisters.html#version-stable-memory[Version stable memory.] (from link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters])
- link:https://mmapped.blog/posts/01-effective-rust-canisters.html#test-upgrades[Test the upgrade hooks.] (from link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters])
- See also the section on upgrades in link:https://www.joachim-breitner.de/blog/788-How_to_audit_an_Internet_Computer_canister[How to audit an Internet Computer canister] (though focused on Motoko)
- Write tests for stable memory to avoid bugs.
- Some libraries (mostly work in progress / partly unfinished) that people work on:
** link:https://github.com/dfinity/stable-structures/[https://github.com/dfinity/stable-structures/]
*** HashMap: link:https://github.com/dfinity/stable-structures/pull/1[https://github.com/dfinity/stable-structures/pull/1] (currently not prod ready)
** link:https://github.com/seniorjoinu/ic-stable-memory-allocator[https://github.com/seniorjoinu/ic-stable-memory-allocator]
- See link:https://wiki.internetcomputer.org/wiki/Current_limitations_of_the_Internet_Computer[Current limitations of the Internet Computer], sections "Long running upgrades" and "[de]serialiser requiring additional wasm memory"
- For example, link:https://github.com/dfinity/internet-identity[internet identity] uses stable memory directly to store user data.

=== Consider encrypting sensitive data on canisters

==== Security Concern

By default, canisters provide integrity but not confidentiality. Data stored on canisters can be read by nodes / replicas.

==== Recommendation

- Consider end-to-end encrypting any private or personal data (e.g. user’s personal or private information) on canisters.
- The example dApp link:https://github.com/dfinity/examples/tree/master/motoko/encrypted-notes-dapp[Encrypted Notes] illustrates how end-to-end encryption can be done.

=== Create backups

==== Security Concern

A canister could be rendered unusable so it could never be upgraded again e.g. due to the following reasons:

* It has a faulty upgrade process (due to some bug from the dapp developer).
* The state becomes inconsistent / corrupt because of a bug in the code that persists data.

==== Recommendation
- Make sure methods used in upgrading are tested or the canister becomes immutable.
- It may be useful to have a disaster recovery strategy that makes it possible to reinstall the canister.
- See the "Backup and recovery" section in link:https://www.joachim-breitner.de/blog/788-How_to_audit_an_Internet_Computer_canister[How to audit an Internet Computer canister]

== Inter-Canister Calls and Rollbacks

=== Don’t panic after await and don’t lock shared resources across await boundaries

==== Security Concern

Panics and traps roll back the canister state. So any state change followed by a trap or panic is of concern. This is also an important concern when inter-canister calls are made. If a panic/trap occurs after an `await` to an inter-canister call, then the state is reverted to the snapshot before the inter-canister call callback invocation (and not before the entire call!).

This may e.g. lead to the following issues:

- If state changes before an inter-canister call leave the state inconsistent and there is a panic after the inter-canister call, this results in inconsistent canister state.
- In particular, if allocated resources (e.g. locks or memory) from before an inter-canister call are not released this can e.g. lead to a canister being locked forever.
- Generally, there can be bugs when data is not persisted when the developer expected it to be.

==== Recommendation

- link:https://mmapped.blog/posts/01-effective-rust-canisters.html#panic-await[Don’t panic after `await`] (from link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters])
- link:https://mmapped.blog/posts/01-effective-rust-canisters.html#dont-lock[Don't lock shared resources across await boundaries] (from link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters])
- See also: "Inter-canister calls" section in link:https://www.joachim-breitner.de/blog/788-How_to_audit_an_Internet_Computer_canister[How to audit an Internet Computer canister]
- For context: link:https://docs.dfinity.systems/spec/public/#rule-message-execution[IC interface spec on message execution]

=== Be aware that state may change during inter-canister calls

==== Security Concern

Messages (but not entire calls) are processed atomically. This can lead to security issues, such as:

- Time-of-check time-of-use: checking some condition on global state before an inter-canister call and wrongly assuming it to still hold when the call returned.

==== Recommendation

- Be aware that state may change during an inter-canister call. Carefully review your code so that this kind of bugs do not occur.
- See also: "Inter-canister calls" section in link:https://www.joachim-breitner.de/blog/788-How_to_audit_an_Internet_Computer_canister[How to audit an Internet Computer canister]

=== Only make inter-canister calls to trustworthy canisters

==== Security Concern

- If inter-canister calls are made to potentially malicious canisters, this can lead to DoS issues or there could be issues related to candid decoding. Also, the data returned from a canister call could be assumed to be trustworthy when it is not.
- If a canister is called with a callback, the receiver can stall indefinitely if the peer does not respond, resulting in DoS. A canister can no longer be upgraded if it is in that state. Recovery would involve reinstalling, wiping the state of the canister.
- In summary, this can DoS a canister, consume an excessive amount of resources, or lead to logic bugs if the behavior of the canister depends on the inter-canister call response.

==== Recommendation

- Only make inter-canister calls to trustworthy canisters.
- Sanitize data returned from inter-canister calls.
- See "Talking to malicious canisters" section in link:https://www.joachim-breitner.de/blog/788-How_to_audit_an_Internet_Computer_canister[How to audit an Internet Computer canister]
- See link:https://wiki.internetcomputer.org/wiki/Current_limitations_of_the_Internet_Computer[Current limitations of the Internet Computer], section "Calling potentially malicious or buggy canisters can prevent canisters from upgrading"

=== Make sure there are no loops in call graphs

==== Security Concern

Loops in the call graph (e.g. canister A calling B, B calling C, C calling A) may lead to canister deadlocks.

==== Recommendation

- Avoid such loops!
- For more information, see link:https://wiki.internetcomputer.org/wiki/Current_limitations_of_the_Internet_Computer[Current limitations of the Internet Computer], section "Loops in call graphs"

== Canister Upgrades

=== Be careful with panics during upgrades

==== Security Concern

If a canister traps or panics in `pre_upgrade`, this can lead to permanently blocking the canister, resulting in a situation where upgrades fail or are no longer possible at all.

==== Recommendation

- Avoid panics / traps in `pre_upgrade` hooks, unless it is truly unrecoverable, so that any invalid state can fixed by upgrading. Panics in the pre-upgrade hook prevent upgrade, and since the pre-upgrade hook is controlled by the old code, it can permanently block upgrading.
- Panic in the `post_upgrade` hook if state is invalid, so that one can retry the upgrade and try to fix the invalid state. Panics in the the post-upgrade hook abort the upgrade, but one can retry with new code.
- link:https://mmapped.blog/posts/01-effective-rust-canisters.html#test-upgrades[Test the upgrade hooks.] (from link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters])
- See also the section on upgrades in link:https://www.joachim-breitner.de/blog/788-How_to_audit_an_Internet_Computer_canister[How to audit an Internet Computer canister] (though focused on Motoko)
- See link:https://wiki.internetcomputer.org/wiki/Current_limitations_of_the_Internet_Computer[Current limitations of the Internet Computer], section "Bugs in `pre_upgrade` hooks"

== Miscellaneous

[[test-your-canister-code]]
=== Test your canister code even in presence of System API calls

==== Security Concern

Since canisters interact with the system API, it is harder to test the code because unit tests cannot call the system API. This may lead to lack of unit tests.

==== Recommendation

- Create loosely coupled modules that do not depend on the system API and unit test those. See this link:https://mmapped.blog/posts/01-effective-rust-canisters.html#target-independent[recommendation] (from link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters]).
- For the parts that still interact with the system API: create a thin abstraction of the System API that is faked in unit tests. See the link:https://mmapped.blog/posts/01-effective-rust-canisters.html#target-independent[recommendation] (from link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters]). For example, one can implement a ‘Runtime’ as follows and then use the ‘MockRuntime’ in tests (code by Dimitris Sarlis):

```rust
    use ic_cdk::api::{
        call::call, caller, data_certificate, id, print, time, trap,
    };

    #[async_trait]
    pub trait Runtime {
        fn caller(&self) -> Result<Principal, String>;
        fn id(&self) -> Principal;
        fn time(&self) -> u64;
        fn trap(&self, message: &str) -> !;
        fn print(&self, message: &str);
        fn data_certificate(&self) -> Option<Vec<u8>>;
        (...)
    }

    #[async_trait]
    impl Runtime for RuntimeImpl {
        fn caller(&self) -> Result<Principal, String> {
            let caller = caller();
            // The anonymous principal is not allowed to interact with the canister.
            if caller == Principal::anonymous() {
                Err(String::from(
                    "Anonymous principal not allowed to make calls.",
                ))
            } else {
                Ok(caller)
            }
        }

        fn id(&self) -> Principal {
            id()
        }

        fn time(&self) -> u64 {
            time()
        }

        (...)

    }

    pub struct MockRuntime {
        pub caller: Principal,
        pub canister_id: Principal,
        pub time: u64,
        (...)
    }

    #[async_trait]
    impl Runtime for MockRuntime {
        fn caller(&self) -> Result<Principal, String> {
            Ok(self.caller)
        }

        fn id(&self) -> Principal {
            self.canister_id
        }

        fn time(&self) -> u64 {
            self.time
        }

        (...)

    }
```


=== Make canister builds reproducible

==== Security Concern

It should be possible to verify that a canister does what it claims to do. The IC provides a SHA256 hash of the deployed WASM module. In order for this to be useful, the canister build has to be reproducible.

==== Recommendation

Make canister builds reproducible. See this link:https://mmapped.blog/posts/01-effective-rust-canisters.html#reproducible-builds[recommendation] (from link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters]). See also link:https://smartcontracts.org/docs/developers-guide/tutorials/reproducible-builds.html[Developer docs on this].

=== Expose metrics from your canister

==== Security Concern

In case of attacks, it is great to be able to obtain relevant metrics from canisters, such as number of accounts, size of internal data structures, stable memory, etc.

==== Recommendation

link:https://mmapped.blog/posts/01-effective-rust-canisters.html#expose-metrics[Expose metrics from your canister.] (from link:https://mmapped.blog/posts/01-effective-rust-canisters.html[Effective Rust Canisters])

=== Don’t rely on time being strictly monotonic

==== Security Concern

The time read from the System API is monotonic, but not strictly monotonic. Thus, two subsequent calls can return the same time, which could lead to security bugs when the time API is used.

==== Recommendation

See the "Time is not strictly monotonic" section in link:https://www.joachim-breitner.de/blog/788-How_to_audit_an_Internet_Computer_canister[How to audit an Internet Computer canister]

[[protect-against-draining-the-cycles-balance]]
=== Protect against draining the cycles balance

==== Security Concern

Canisters pay for their cycles which makes them inherently vulnerable to attacks that consume all their cycles.

==== Recommendation

Consider monitoring, early authentication, rate limiting on canister level to mitigate this. Also, be aware that an attacker will aim for the call consuming most cycles. See the "Cycle balance drain attacks section" in link:https://www.joachim-breitner.de/blog/788-How_to_audit_an_Internet_Computer_canister[How to audit an Internet Computer canister] .

== Nonspecific to the Internet Computer

The best practices in this section are very general and not specific to the Internet Computer. This list is by no means complete and only lists a few very specific concerns that have led to issues in the past.

=== Validate inputs

==== Security Concern

The data sent in link:https://smartcontracts.org/docs/interface-spec/index.html#http-interface[query and update calls] is generally untrusted. The message size limit is a few MB. This can e.g. lead the following issues:

- If unvalidated data is rendered in web UIs or displayed in other systems, this can lead to injection attacks (e.g. XSS).
- Messages of big size could be sent and potentially stored in the canister, consuming an excessive amount of storage.
- Big inputs (e.g. big lists or strings) could trigger an excessive amount of computation, resulting in DoS and consuming many cycles. See also link:rust-canister-development-security-best-practices#protect-against-draining-the-cycles-balance[Protect against draining the cycles balance]

==== Recommendation

- Perform input validation, see e.g. the link:https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html[OWASP cheat sheet].
- "Large data attacks" section in link:https://www.joachim-breitner.de/blog/788-How_to_audit_an_Internet_Computer_canister[How to audit an Internet Computer canister] (be aware of Candid space bombs)
- link:https://owasp.org/www-project-application-security-verification-standard/[ASVS] 5.1.4: Verify that structured data is strongly typed and validated against a defined schema including allowed characters, length and pattern (e.g. credit card numbers or telephone, or validating that two related fields are reasonable, such as checking that suburb and zip/postcode match).

=== Rust: Don’t use unsafe Rust code

==== Security Concern

Unsafe Rust code is risky because it may introduce memory corruption issues.

==== Recommendation

- Avoid unsafe code whenever possible.
- See the link:https://anssi-fr.github.io/rust-guide/04_language.html#unsafe-code[Rust security guidelines]
- Consider the link:https://docs.dfinity.systems/dfinity/spec/meta/rust.html#_avoid_unsafe_code[Dfinity Rust Guidelines].

=== Rust: Avoid integer overflows

==== Security Concern

Integers in Rust may overflow. While such overflows lead to panics in the debug configuration, the values are just wrapped around silently in release compilation. This can cause major security issues e.g. when the integers are used as indices, unique IDs, or if cycles or ICP amounts are computed.

==== Recommendation

- Review your code carefully for any integer operations that may wrap around.
- Use the `saturated` or `checked` variants of these operations, such as `saturated_add`, `saturated_sub`, `checked_add` , `checked_sub`, etc. See e.g. the link:https://doc.rust-lang.org/std/primitive.u32.html#method.saturating_add[Rust docs] for `u32`.
- See also the link:https://anssi-fr.github.io/rust-guide/04_language.html#integer-overflows[Rust security guidelines on integer overflows].

=== For expensive calls, consider using captchas or proof of work

==== Security Concern

If an update or query call is expensive e.g. in terms of memory used or cycles consumed, this may make it easy for bots to render the canister unusable (e.g. by filling up it’s storage).

==== Recommendation

If the dApp offers such operations, consider bot prevention techniques such as adding Captchas or proof of work. There is e.g. a captcha implementation in link:https://github.com/dfinity/internet-identity[internet identity].



////
